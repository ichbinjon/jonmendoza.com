<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fixing a 30-Second Search Query at Apple - Jonathan Mendoza</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/bundle.css" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <meta name="theme-color" content="#d4faf5">

    <meta property="og:title" content="Fixing a 30-Second Search Query at Apple - Jonathan Mendoza">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://jonmendoza.com/blog/posts/fixing-30-second-search-query/">
    <meta property="og:image" content="https://jonmendoza.com/android-chrome-512x512.png">
    <meta property="og:description" content="Nobody waits 30 seconds to search. We had to fix it.">
    <meta property="og:site_name" content="Jonathan Mendoza">
    <meta property="og:locale" content="en_US">
  </head>
  <body>
    <main class="blog-container">
  <article class="post">
    <header class="post-header">
      <a href="/" class="back-link">&larr; Home</a>
      <h1>Fixing a 30-Second Search Query at Apple</h1>
      <time datetime="2025-12-28">December 28, 2025</time>
    </header>
    <div class="post-content">
      <p>Search took 30 seconds. We weren't going to launch like that.</p>
<p>A wiki you can't search is just a pile of documents. Nobody's going to wait 30 seconds to find something. They'll just ping a coworker instead.</p>
<p>This was 2020. I was a new grad at Apple, fresh off a rotational program, and I'd landed on a team building an internal wiki. Think Notion, but with deep integrations into Apple's infrastructure. Org charts, access control, automations, all of it.</p>
<p>This thing was supposed to be Apple-wide. Other teams had their own Confluence instances or whatever, but those were siloed. If someone on the iPhone team needed to share docs with someone in a totally different org, this was going to be the way. It eventually hit 150k daily active users.</p>
<p>But first, we had to fix search.</p>
<h2>Why it was slow</h2>
<p>Apple cares a lot about information security. Every document had access control rules. Who could see it based on their team, what NDAs they'd signed, what org they were in. You could set permissions at the space level, folder level, or individual page. Rules inherited or overrode each other. Powerful, but complicated.</p>
<p>We used Solr for search. It's an open-source search engine, pretty standard for this kind of thing. To enforce access control, we had a PostFilter that ran after every query. The way PostFilters work: after the main query runs, Solr calls your filter's collect() method for every matching document. Our filter would call out to a graph database to check if the user had access to that document. If they did, pass it through. If not, skip it.</p>
<p>So if your query matched 10,000 documents, we made 10,000 calls to the graph database. Even if you only wanted 25 results.</p>
<p>Pagination made it worse. To render page 2, you can't just check documents 26-50. You have to run the filter on everything before it to know what actually belongs on each page.</p>
<!-- TODO: Diagram showing the PostFilter flow: query matches 10,000 docs → collect() called 10,000 times → each one hits graph DB → finally get 25 results. Show the disproportion. -->
<p>This was blocking launch. I got assigned to fix it.</p>
<h2>The fix</h2>
<p>I didn't have some genius insight. I just looked at it long enough that the obvious answer became obvious: stop checking permissions after you find documents. Make permissions part of how you find documents.</p>
<p>So I indexed every document with its access control rules baked in. User IDs, group IDs, NDA IDs. All flattened into fields in Solr. When someone searches, their permissions are just another filter in the query. One call, no external lookups.</p>
<!-- TODO: Diagram showing the new search flow: user query + user's permissions → Solr → results. Clean, single step. -->
<p>The idea was simple. Actually doing it was harder.</p>
<p>I was a new grad proposing a complete rearchitecture of how we indexed pages into search. This wasn't a tweak. It was rethinking the whole approach, and I was going to do it mostly on my own. The stakes were high. At Apple, an access control incident isn't just a bug, it's a serious data privacy issue. If someone saw a document they weren't supposed to, even for a second, that's bad. Really bad.</p>
<p>So I had to get it right.</p>
<p>The tricky part is keeping the index up to date. ACLs change all the time. Someone gets added to a folder, someone leaves a team, an NDA expires. You can't just index once and forget about it.</p>
<p>So I set up an event-driven system. Whenever a page's ACL changed, it published an event to a queue. A worker would pick up that event, look up the current state of the document's permissions, flatten them into the list of user IDs, group IDs, and NDA IDs that should have access, and push an update to Solr.</p>
<!-- TODO: Diagram of the event-driven indexing: ACL change → event queue → worker → Solr update. Simple pipeline. -->
<p>Took about two weeks to build. This was pre-LLMs, so it was just me reading Solr documentation and thinking hard.</p>
<h2>The tradeoff</h2>
<p>The whole thing was async. That means there's a window where the index is stale.</p>
<p>If someone loses access to a doc, they might still see it in search results for a few seconds until the job runs. We decided that was fine. If you could see something a moment ago, seeing it for two more seconds isn't a disaster.</p>
<p>I added telemetry to track the indexing lag. It stayed in the low seconds.</p>
<!-- TODO: A simple chart or gauge showing indexing lag staying under a few seconds. Maybe a dashboard screenshot aesthetic. -->
<h2>The result</h2>
<p>First time I ran a query after flipping this on: under a second.</p>
<p>I didn't trust it. Ran it again. Pulled up a few documents from the results to make sure they were actually documents I should have access to. Half expecting to find something leaked from a team I'd never heard of. Everything checked out. It was actually working.</p>
<p>30 seconds down to under one.</p>
<!-- TODO: Before/after comparison: two search bars, one with a spinner and '30s', one with results and '<1s'. Keep it simple. -->
<h2>What happened after</h2>
<p>The wiki launched. Did exactly what it was supposed to do. Became the connective tissue for documentation across Apple.</p>
<p>After that, things moved on the way they do. My mentor left the company. Engineers rotated to other projects. I eventually did too. The wiki kept running. It just wasn't the main thing anymore.</p>
<p>But I'm still proud of those two weeks in 2020, staring at a 30-second query and figuring out how to make it fast.</p>

    </div>
  </article>
</main>

  </body>
</html>
